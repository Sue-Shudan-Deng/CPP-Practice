{"id":418945107,"lang":"python3","lang_name":"Python3","time":"2 years, 9 months","timestamp":1605043670,"status":10,"status_display":"Accepted","runtime":"116 ms","url":"/submissions/detail/418945107/","is_pending":"Not Pending","title":"Minimum Cost Tree From Leaf Values","memory":"14.1 MB","code":"class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n = len(arr)\n        m = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            m[i][i] = arr[i]\n            for j in range(i + 1, n):\n                m[i][j] = max(m[i][j-1], arr[j])\n        \"\"\"\n        method 1: recursion with mem\n        \"\"\"\n#         dp = [[0 for _ in range(n)] for _ in range(n)]\n#         def dfs(i, j):\n#             if i == j:\n#                 dp[i][j] = 0\n#                 return 0\n#             if dp[i][j]:\n#                 return dp[i][j]\n#             tmp = float(\"inf\")\n#             for k in range(i, j):\n#                 tmp = min(tmp, dfs(i, k) + dfs(k+1, j) + maxarray[i][k] * maxarray[k+1][j])\n#             dp[i][j] = tmp\n#             return tmp\n                \n#         return dfs(0, len(arr) - 1)\n        \"\"\"\n        method 2: DP\n        \"\"\"\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        # 一定要注意到着来！！！\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = min([dp[i][k] + dp[k+1][j] + m[i][k] * m[k+1][j] for k in range(i, j)])\n        return dp[0][n-1]","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-cost-tree-from-leaf-values","has_notes":false,"flag_type":1}