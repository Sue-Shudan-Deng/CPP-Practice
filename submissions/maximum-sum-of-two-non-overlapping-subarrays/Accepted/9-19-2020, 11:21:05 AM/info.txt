{"id":397947124,"lang":"cpp","lang_name":"C++","time":"2 years, 11 months","timestamp":1600539665,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/397947124/","is_pending":"Not Pending","title":"Maximum Sum of Two Non-Overlapping Subarrays","memory":"9.7 MB","code":"class Solution {\npublic:\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\n        if (A.size() < L + M) {\n            return 0;\n        }\n        int cnt = 0;\n        int n = A.size();\n        vector<int> prefix(n+1, 0);\n        for (int i = 0; i < n; ++i) {\n            cnt += A[i];\n            prefix[i+1] = cnt;\n        }\n        vector<vector<int>> dp(n+1, vector<int>(2, 0));\n        // 这里有两种方案\n        // 第一种是我使用当前位置的后L个作为L数组，然后反复迭代确定前i-L中最大的M数组\n        // 第一种是我使用当前位置的后M个作为M数组，然后反复迭代确定前i-M中最大的L数组\n        int Lmax = prefix[L];\n        int Mmax = prefix[M];\n        int res = 0;\n        for (int i = L+M; i <= n; ++i) {\n            Lmax = max(Lmax, prefix[i-M] - prefix[i-M-L]);\n            Mmax = max(Mmax, prefix[i-L] - prefix[i-M-L]);\n            res = max(res, max(Lmax + prefix[i] - prefix[i-M], \n                               Mmax + prefix[i] - prefix[i-L]));\n        }\n        return res;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"maximum-sum-of-two-non-overlapping-subarrays","has_notes":false,"flag_type":1}