{"id":417827393,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1604781166,"status":10,"status_display":"Accepted","runtime":"24 ms","url":"/submissions/detail/417827393/","is_pending":"Not Pending","title":"Evaluate Division","memory":"14.2 MB","code":"class Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        \"\"\"\n        method 1: backtrack\n        这道题我的主要问题在于第一次想没有想到要用backtrack\n        和robotcleaner类似，只要当前已经访问过的节点不能再次被访问(否则dfs将会成环，那么都需要思考backtrack)\n        \"\"\"\n        \n#         graph = defaultdict(defaultdict)\n#         for i, (p, q) in enumerate(equations):\n#             graph[p][q] = values[i]\n#             graph[q][p] = 1.0 / values[i]\n            \n#         def backtrack(cur, end, ans, visited):\n#             # set\n#             res = -1.0\n#             neis = graph[cur]\n#             visited.add(cur)\n#             for nei in neis:\n#                 if nei in visited:\n#                     continue\n#                 if nei == end:\n#                     return ans * graph[cur][nei]\n#                 res = backtrack(nei, end, ans * graph[cur][nei], visited)\n#                 if res != -1:\n#                     return res\n#             # clear\n#             visited.remove(cur)\n#             return -1\n                \n#         res = []\n#         for begin, end in queries:\n#             if not begin in graph or not end in graph:\n#                 res.append(-1.0)\n#             elif begin == end:\n#                 res.append(1.0)\n#             else:\n#                 visited = set()\n#                 res.append(backtrack(begin, end, 1.0, visited))\n#         return res\n    \n        \"\"\"\n        method 2: union find\n        \"\"\"\n        parent = collections.defaultdict(list)\n        def find(x):\n            \"\"\"\n            这个函数需要仔细理解\n            \"\"\"\n            if x != parent[x][0]:\n                p = find(parent[x][0])\n                parent[x][0] = p[0]\n                parent[x][1] *= p[1]\n            return parent[x]\n                \n        for idx, (u, v) in enumerate(equations):\n            k = values[idx] # u / v = k\n            if not parent[u] and not parent[v]:\n                # second node as parent\n                parent[u] = [v, k]\n                parent[v] = [v, 1.0]\n            elif not parent[u]:\n                # second node as parent\n                parent[u] = [v, k]\n            elif not parent[v]:\n                # first node as parent\n                parent[v] = [u, 1 / k]\n            else:\n                # second node as parent\n                pu = parent[u]\n                pv = parent[v]\n                # u / pu = pu.second\n                # v / pv = pv.second\n                # u / v = k\n                # pu / pv = 1 / pu.second * k * pv.second\n                parent[pu[0]] = [pv[0], (1 / pu[1]) * k * pv[1]]\n        \n        ans = []\n        for u, v in queries:\n            if not parent[u] or not parent[v]:\n                ans.append(-1.0)\n                continue\n            if u == v:\n                ans.append(1.0)\n                continue\n            pu, pv = find(u), find(v)\n            if pu[0] != pv[0]:\n                # they don't even belong to the same cluster\n                ans.append(-1.0)\n            else:\n                # pu.second = u / root\n                # pv.second = v / root\n                # u / v = pu.second / pv.second\n                ans.append(pu[1] / pv[1])\n        return ans\n    \n    ","compare_result":"1111111111111111111111","title_slug":"evaluate-division","has_notes":false,"flag_type":1}