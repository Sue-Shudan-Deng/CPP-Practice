{"id":399326370,"lang":"python3","lang_name":"Python3","time":"2 years, 11 months","timestamp":1600801764,"status":10,"status_display":"Accepted","runtime":"28 ms","url":"/submissions/detail/399326370/","is_pending":"Not Pending","title":"Evaluate Division","memory":"14.1 MB","code":"class Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        \"\"\"\n        这道题我的主要问题在于第一次想没有想到要用backtrack\n        和robotcleaner类似，只要当前已经访问过的节点不能再次被访问(否则dfs将会成环，那么都需要思考backtrack)\n        \"\"\"\n        graph = defaultdict(defaultdict)\n        for i, (p, q) in enumerate(equations):\n            graph[p][q] = values[i]\n            graph[q][p] = 1.0 / values[i]\n            \n        def backtrack(cur, end, ans, visited):\n            # set\n            visited.add(cur)\n            res = -1.0\n            neis = graph[cur]\n            for nei in neis:\n                if nei in visited:\n                    continue\n                if nei == end:\n                    return ans * graph[cur][nei]\n                res = backtrack(nei, end, ans * graph[cur][nei], visited)\n                if res != -1:\n                    return res\n            # clear\n            visited.remove(cur)\n            return res        \n                \n        res = []\n        for begin, end in queries:\n            if not begin in graph or not end in graph:\n                res.append(-1.0)\n            elif begin == end:\n                res.append(1.0)\n            else:\n                visited = set()\n                res.append(backtrack(begin, end, 1.0, visited))\n        return res","compare_result":"1111111111111111111111","title_slug":"evaluate-division","has_notes":false,"flag_type":1}