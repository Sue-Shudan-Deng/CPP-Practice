{"id":398992194,"lang":"python3","lang_name":"Python3","time":"2 years, 11 months","timestamp":1600742531,"status":10,"status_display":"Accepted","runtime":"140 ms","url":"/submissions/detail/398992194/","is_pending":"Not Pending","title":"Word Ladder","memory":"17.5 MB","code":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        \"\"\"\n        BFS，重点是通过创建all_combo这个dict来剪枝，否则需要像花花那样遍历所有字母\n        \"\"\"\n        if not beginWord or not endWord or not wordList or endWord not in wordList:\n            return 0\n        all_combo = collections.defaultdict(list)\n        L = len(beginWord)\n        for word in wordList:\n            for i in range(L):\n                all_combo[word[:i] + '*' + word[i+1:]].append(word)\n        # if wordList has 6 words and each word has 3 letters, then\n        # the size of all_combo is 6*3 = 18\n        visited, step = {beginWord: True}, 1\n        queue = collections.deque([(beginWord, step)])\n        while queue:\n            word, step = queue.popleft()\n            for i in range(L):\n                for w in all_combo[word[:i] + '*' + word[i+1:]]:\n                    if w == endWord:\n                        return step + 1\n                    if w == word or visited.get(w, False):\n                        continue\n                    if not visited.get(w, False):\n                        # 注：这里step和visited可以合并\n                        visited[w] = True\n                        queue.append((w, step + 1))\n                # 这里的作用是为了剪枝省时间，可以不写\n                all_combo[word[:i] + '*' + word[i+1:]] = []\n        return 0\n    \n# class Solution:\n#     def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n#         \"\"\"\n#         双向BFS\n#         \"\"\"\n#         # 前面这几行都是一样的\n#         if not beginWord or not endWord or not wordList or endWord not in wordList:\n#             return 0\n#         all_combo = collections.defaultdict(list)\n#         L = len(beginWord)\n#         for word in wordList:\n#             for i in range(L):\n#                 all_combo[word[:i] + '*' + word[i+1:]].append(word)\n#         visited_start = {beginWord: 1}\n#         visited_end = {endWord: 1}\n        \n#         # Queues for birdirectional BFS\n#         queue_begin = collections.deque([(beginWord, 1)]) # BFS starting from beginWord\n#         queue_end = collections.deque([(endWord, 1)]) # BFS starting from endWord\n        \n#         def visitWordNode(queue, visited, others_visited):\n#             word, step = queue.popleft()\n#             for i in range(L):\n#                 for w in all_combo[word[:i] + '*' + word[i+1:]]:\n#                     if others_visited.get(w, 0):\n#                         return step + others_visited[w] \n#                     if w == word or visited.get(w, 0):\n#                         continue\n#                     if not visited.get(w, 0):\n#                         # 注：这里step和visited可以合并\n#                         visited[w] = step + 1\n#                         queue.append((w, step + 1))\n#             return None\n        \n#         # 这里建立两个queue是因为同时对两个方向BFS\n#         # 如果有一个方向的queue变成空，那么说明该方向BFS已经结束，并且不可能到达\n#         while queue_begin and queue_end:\n#             ans = visitWordNode(queue_begin, visited_start, visited_end)\n#             if ans:\n#                 return ans\n#             ans = visitWordNode(queue_end, visited_end, visited_start)\n#             if ans:\n#                 return ans\n#         return 0","compare_result":"1111111111111111111111111111111111111111111","title_slug":"word-ladder","has_notes":false,"flag_type":1}