{"id":399027674,"lang":"cpp","lang_name":"C++","time":"2 years, 11 months","timestamp":1600748001,"status":10,"status_display":"Accepted","runtime":"448 ms","url":"/submissions/detail/399027674/","is_pending":"Not Pending","title":"Word Ladder","memory":"33 MB","code":"class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        // BFS\n        map<string, vector<string>> all_comb;\n        map<string, bool> visited;\n        int n = beginWord.size();\n        for (auto w : wordList) {\n            for (int i = 0; i < n; ++i) {\n                all_comb[w.substr(0, i) + \"*\" + w.substr(i+1, n-i-1)].push_back(w);\n            }\n            visited[w] = false;\n        }\n        deque<pair<string, int>> q = {{beginWord, 1}};\n        if (find(wordList.begin(), wordList.end(), endWord) == wordList.end()) {\n            return 0;\n        }\n        \n        visited[beginWord] = true;\n        while (!q.empty()) {\n            auto [w, step] = q.front();\n            q.pop_front();\n            for (int i = 0; i < n; ++i) {\n                for (auto next_w : all_comb[w.substr(0, i) + \"*\" + w.substr(i+1, n-i-1)]) {\n                    if (next_w == endWord) {\n                        return step + 1;\n                    }\n                    if (!visited[next_w]) {\n                        visited[next_w] = true;\n                        q.emplace_back(next_w, step + 1);\n                    }   \n                }\n                all_comb.erase(w.substr(0, i) + \"*\" + w.substr(i+1, n-i-1));\n            }\n        }\n        return 0;\n    }\n};\n    \n//     int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n//         // Bidirectional BFS\n//         map<string, vector<string>> all_comb;\n//         map<string, int> visited_forward;\n//         map<string, int> visited_backward;\n//         int n = beginWord.size();\n//         for (auto w : wordList) {\n//             for (int i = 0; i < n; ++i) {\n//                 all_comb[w.substr(0, i) + \"*\" + w.substr(i+1, n-i-1)].push_back(w);\n//             }\n//         }\n//         deque<pair<string, int>> q_forward = {{beginWord, 1}};\n//         deque<pair<string, int>> q_backward = {{endWord, 1}};\n//         visited_forward[beginWord] = 1;\n//         visited_backward[endWord] = 1;\n//         string w;\n//         int step;\n        \n//         if (find(wordList.begin(), wordList.end(), endWord) == wordList.end()) {\n//             return 0;\n//         }\n        \n//         while (!q_forward.empty() && !q_backward.empty()) {\n//             tie(w, step) = q_forward.front();\n//             q_forward.pop_front();\n//             for (int i = 0; i < n; ++i) {\n//                 for (auto next_w : all_comb[w.substr(0, i) + \"*\" + w.substr(i+1, n-i-1)]) {\n//                     if (visited_backward.count(next_w)) {\n//                         cout << \"w: \" << w << \" next_w: \" << next_w << endl;\n//                         return step + visited_backward[next_w];\n//                     }\n//                     if (!visited_forward.count(next_w)) {\n//                         visited_forward[next_w] = step + 1;\n//                         q_forward.emplace_back(next_w, step + 1);\n//                     }   \n//                 }\n//                 // 这里因为双向的做法，剪枝就不太合适了\n//                 // all_comb.erase(w.substr(0, i) + \"*\" + w.substr(i+1, n-i-1));\n//             }\n            \n//             tie(w, step) = q_backward.front();\n//             q_backward.pop_front();\n//             for (int i = 0; i < n; ++i) {\n//                 for (auto next_w : all_comb[w.substr(0, i) + \"*\" + w.substr(i+1, n-i-1)]) {\n//                     if (visited_forward.count(next_w)) {\n//                         return step + visited_forward[next_w];\n//                     }\n//                     if (!visited_backward.count(next_w)) {\n//                         visited_backward[next_w] = step + 1;\n//                         q_backward.emplace_back(next_w, step + 1);\n//                     }   \n//                 }\n//             }\n//         }\n//         return 0;\n//     }\n// };","compare_result":"1111111111111111111111111111111111111111111","title_slug":"word-ladder","has_notes":false,"flag_type":1}