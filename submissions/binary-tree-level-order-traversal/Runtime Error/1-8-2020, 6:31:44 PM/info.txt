{"id":292525395,"lang":"python3","lang_name":"Python3","time":"3 years, 8 months","timestamp":1578537104,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/292525395/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"N/A","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n# Recursion:\n# class Solution:\n#     def levelOrder(self, root: TreeNode) -> List[List[int]]:\n#         res = []\n#         def helper(node: TreeNode, level: int):\n#             if node:\n#                 if len(res) == level:\n#                     res.append([])\n#                 res[level].append(node.val)\n#                 helper(node.left, level+1)\n#                 helper(node.right, level+1)\n#         helper(root, 0)\n#         return res\n\n# Interative:\nfrom collections import deque\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        level = 0\n        res = []\n        queue = deque([root])\n        while queue:\n            res.append([])\n            # 原则: 对于每一层，先把改层对应的queue的总长度作为\n            # queue的长度，然后清空queue\n            level_length = len(queue)\n            for i in range(level_length):\n                node = queue.popleft()\n                res[level].append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            level += 1\n            \n        return res\n            \n        \n            \n            ","compare_result":"1000000000000000000000000000000000","title_slug":"binary-tree-level-order-traversal","has_notes":false,"flag_type":1}