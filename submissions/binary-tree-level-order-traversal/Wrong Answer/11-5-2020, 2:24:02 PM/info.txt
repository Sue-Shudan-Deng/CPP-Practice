{"id":417204479,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1604615042,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/417204479/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"N/A","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n# DFS\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        ans = [[]]\n        def dfs(root, depth, ans):\n            if not root:\n                return\n            if len(ans) < depth + 1:\n                ans.append([])\n            ans[depth].append(root.val)\n            dfs(root.left, depth + 1, ans)\n            dfs(root.right, depth + 1, ans)\n        dfs(root, 0, ans)\n        return ans\n\n# Iterative:\n# class Solution:\n#     def levelOrder(self, root: TreeNode) -> List[List[int]]:\n#         if not root: return []\n#         ret, level = [], 0\n#         queue = collections.deque([root])\n#         while queue:\n#             ret.append([])\n#             level_length = len(queue)\n#             for i in range(level_length):\n#                 root = queue.popleft()\n#                 ret[level].append(root.val)\n#                 if root.left: queue.append(root.left)\n#                 if root.right: queue.append(root.right)\n#             level += 1\n#         return ret","compare_result":"1011111111111111111111111111111111","title_slug":"binary-tree-level-order-traversal","has_notes":false,"flag_type":1}