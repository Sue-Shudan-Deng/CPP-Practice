{"id":418272531,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1604884061,"status":10,"status_display":"Accepted","runtime":"808 ms","url":"/submissions/detail/418272531/","is_pending":"Not Pending","title":"Target Sum","memory":"14.5 MB","code":"class Solution:\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\n        \"\"\"\n        method 1: 常规解法\n        https://www.youtube.com/watch?v=r6Wz4W1TbuI&t=1239s\n        注意像这样的常规解法也是很重要的\n        \"\"\"\n        n = len(nums)\n        summ = sum(nums)\n        if summ < S:\n            return 0\n         \n        # 这里的offset是必要的，为了使得二维数组的第二维index合法\n        offset = summ\n        dp = [[0 for _ in range(2 * summ + 1)] for _ in range(n+1)]\n        # dp[i][j] 表示用第i个num能达到j的情况有多少种\n        dp[0][offset] = 1\n        \n        for i in range(1, n + 1):\n            for j in range(summ + offset - nums[i-1], nums[i-1] - 1, -1):\n                dp[i][j - nums[i-1]] += dp[i-1][j]\n                dp[i][j + nums[i-1]] += dp[i-1][j]\n                    \n        return dp[n][S+offset]\n    \n# class Solution:\n#     def findTargetSumWays(self, nums: List[int], S: int) -> int:\n#         \"\"\"\n#         method 2: bounded knapsack\n#         https://www.youtube.com/watch?v=zks6mN06xdQ 重点还是理解21min的图\n#         \"\"\"\n#         n = len(nums)\n#         summ = sum(nums)\n#         if summ < S or (summ + S) % 2:   # 必须被2整除\n#             return 0\n        \n#         target = (summ + S) // 2\n#         dp = [0 for _ in range(target + 1)]\n#         dp[0] = 1\n#         for num in nums:\n#             for j in range(target, num - 1, -1):\n#                 dp[j] += dp[j - num]\n#         return dp[target]","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"target-sum","has_notes":false,"flag_type":1}