{"id":407905261,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1602529939,"status":10,"status_display":"Accepted","runtime":"44 ms","url":"/submissions/detail/407905261/","is_pending":"Not Pending","title":"Combination Sum IV","memory":"14.1 MB","code":"class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        My method 1: Unbounded knapsack + intentionally added combination duplicates, TLE\n        \"\"\"\n        # if not nums or min(nums) > target:\n        #     return 0\n        # nums.sort()\n        # dp = [[] for _ in range(target + 1)]\n        # for num in nums:\n        #     for i in range(num, target + 1):\n        #         if i == num:\n        #             dp[num].append({num:1})\n        #         else:\n        #             for c in dp[i - num]:\n        #                 p = copy.deepcopy(c)\n        #                 p[num] = p.get(num, 0) + 1\n        #                 dp[i].append(p)\n        # res = dp[target]\n        # def perturbation(x: dict) -> int:\n        #     p = math.factorial(sum(x.values()))\n        #     for i in x.values():\n        #         p /= math.factorial(i)\n        #     return p\n        # return int(sum([perturbation(i) for i in res]))\n\n        \"\"\"\n        My method 2: Reverse the for loop to satisfy the unordering property on Unbounded knapsack, passed\n        \"\"\"\n        if not nums or min(nums) > target:\n            return 0\n        dp = [0 for _ in range(target + 1)]\n        dp[0] = 1\n        for i in range(1, target + 1):\n            for num in nums:\n                if i >= num:\n                    dp[i] += dp[i - num]\n        return dp[target]","compare_result":"11111111111111111","title_slug":"combination-sum-iv","has_notes":false,"flag_type":1}