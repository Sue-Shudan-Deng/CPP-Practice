{"id":399270851,"lang":"cpp","lang_name":"C++","time":"2 years, 11 months","timestamp":1600793034,"status":10,"status_display":"Accepted","runtime":"44 ms","url":"/submissions/detail/399270851/","is_pending":"Not Pending","title":"Count Complete Tree Nodes","memory":"31.1 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    \nprivate:\n    int computeDepth(TreeNode* root) {\n        // 根据最后一层最左边的node即可判断\n        // root节点位于level 0\n        int d = 0;\n        while (root->left) {\n            ++d;\n            root = root->left;\n        }\n        return d;\n    }\n    \n    TreeNode* exist(int idx, int d, TreeNode* root) {\n        int l = 0, r = pow(2, d) - 1, m = 0;\n        for (int i = 0; i < d; ++i) {\n            // 这样写，退出的时候l=r，没啥问题\n            m = l + (r - l) / 2;\n            if (idx <= m) {\n                // 这里取 r = m 而不是 r = m - 1 并不是无缘无故的，\n                // 因为上面的判断是包含了idx == m\n                // 可以用这种方式来记忆\n                r = m;\n                root = root->left;\n            } else {\n                l = m + 1;\n                root = root->right;\n            }\n        }\n        return root ? root : nullptr;\n    }\n    \npublic:\n    int countNodes(TreeNode* root) {\n        if (!root) {\n            return 0;\n        }\n        int d = computeDepth(root);\n        if (d == 0) {\n            return 1;\n        }\n        int l = 0, r = pow(2, d) - 1, m = 0;\n        while (l <= r) {\n            // 退出条件：l = r + 1，合理，因为我们需要node的个数而不是index\n            m = l + (r - l) / 2;\n            if (exist(m, d, root)) {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n        return pow(2, d) - 1 + l;\n    }\n};","compare_result":"111111111111111111","title_slug":"count-complete-tree-nodes","has_notes":false,"flag_type":1}