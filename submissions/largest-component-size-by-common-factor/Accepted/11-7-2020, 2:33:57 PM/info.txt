{"id":417856906,"lang":"python","lang_name":"Python","time":"2 years, 10 months","timestamp":1604788437,"status":10,"status_display":"Accepted","runtime":"2724 ms","url":"/submissions/detail/417856906/","is_pending":"Not Pending","title":"Largest Component Size by Common Factor","memory":"20.1 MB","code":"class Solution:\n    def largestComponentSize(self, A):\n        dsu = DisjointSetUnion(max(A))\n        num_factor_map = {}\n        \n        for num in A:\n            prime_factors = list(set(self.primeDecompose(num)))\n            # map a number to its first prime factor\n            num_factor_map[num] = prime_factors[0]\n            # merge all groups that contain the prime factors.\n            for i in range(0, len(prime_factors)-1):\n                dsu.union(prime_factors[i], prime_factors[i+1])\n        \n        max_size = 0\n        group_count = defaultdict(int)\n        for num in A:\n            group_id = dsu.find(num_factor_map[num])\n            group_count[group_id] += 1\n            max_size = max(max_size, group_count[group_id]) \n        \n        return max_size\n\n\n    def primeDecompose(self, num):\n        \"\"\" decompose any positive number into \n                a series of prime factors.\n            e.g. 12 = 2 * 2 * 3\n        \"\"\"\n        factor = 2\n        prime_factors = []\n        while num >= factor * factor:\n            if num % factor == 0:\n                prime_factors.append(factor)\n                num = num // factor\n            else:\n                factor += 1\n        prime_factors.append(num)\n        return prime_factors\n\n\nclass DisjointSetUnion:\n\n    def __init__(self, size):\n        # initially, each node is an independent component\n        self.parent = [i for i in range(size+1)]\n        # keep the size of each component\n        self.size = [1] * (size+1)\n    \n    def find(self, x):\n        \"\"\" return the component id that the element x belongs to. \"\"\"\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        \"\"\" merge the two components that x, y belongs to respectively,\n              and return the merged component id as the result.\n        \"\"\"\n        px, py = self.find(x), self.find(y)\n        \n        # the two nodes share the same set\n        if px == py:\n            return px\n        \n        # otherwise, connect the two sets (components)\n        if self.size[px] > self.size[py]:\n            # add the node to the union with less members.\n            # keeping px as the index of the smaller component\n            px, py = py, px\n        # add the smaller component to the larger one\n        self.parent[px] = py\n        self.size[py] += self.size[px]\n        # return the final (merged) group\n        return py","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"largest-component-size-by-common-factor","has_notes":false,"flag_type":1}