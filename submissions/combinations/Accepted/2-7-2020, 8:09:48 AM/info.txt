{"id":301087458,"lang":"python3","lang_name":"Python3","time":"3 years, 7 months","timestamp":1581091788,"status":10,"status_display":"Accepted","runtime":"524 ms","url":"/submissions/detail/301087458/","is_pending":"Not Pending","title":"Combinations","memory":"14.3 MB","code":"class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        def backtrack(first: int, curr: List[int]):\n            if len(curr) == k:\n                res.append(curr[:]) # 这里写成res.append(curr)会报错\n                return\n            for i in range(first, n + 1):\n                curr.append(i) # 置位\n                backtrack(i+1, curr) # 回溯\n                curr.pop() # 复位\n        backtrack(1, [])\n        return res\n    \n\"\"\"\na = [1, 2, 3]\nb1 = a\nb2 = a[:]\nb1是a的浅拷贝，即b1和a一样\nb2是a的深拷贝，即b2和a不一样\n\nb1和b2的内容和a都是一样的，\n但是b1的内存地址和a一样，b2的内存地址和a是不一样的\n\n此处的这个就像按引用传递（b1）和按值传递（b2）\n\"\"\"\n","compare_result":"111111111111111111111111111","title_slug":"combinations","has_notes":false,"flag_type":1}