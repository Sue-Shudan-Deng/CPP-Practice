{"id":417587773,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1604715507,"status":10,"status_display":"Accepted","runtime":"528 ms","url":"/submissions/detail/417587773/","is_pending":"Not Pending","title":"Combinations","memory":"15.6 MB","code":"class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        def backtrack(start: int, ans: List[int]):\n            if len(ans) == k:\n                res.append(ans[:]) # 这里写成res.append(curr)会报错\n                return\n            for i in range(start, n + 1):\n                backtrack(i+1, ans + [i]) # 回溯\n        backtrack(1, [])\n        return res\n    \n\"\"\"\na = [1, 2, 3]\nb1 = a\nb2 = a[:]\nb1是a的浅拷贝，即b1和a一样\nb2是a的深拷贝，即b2和a不一样\n\nb1和b2的内容和a都是一样的，\n但是b1的内存地址和a一样，b2的内存地址和a是不一样的\n\n此处的这个就像按引用传递（b1）和按值传递（b2）\n\"\"\"\n","compare_result":"111111111111111111111111111","title_slug":"combinations","has_notes":false,"flag_type":1}