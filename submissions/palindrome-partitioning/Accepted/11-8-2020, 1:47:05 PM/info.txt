{"id":418217736,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1604872025,"status":10,"status_display":"Accepted","runtime":"64 ms","url":"/submissions/detail/418217736/","is_pending":"Not Pending","title":"Palindrome Partitioning","memory":"14.8 MB","code":"class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n#         \"\"\"\n#         method 1: naive backtrack\n#         \"\"\"\n#         def isPalindrome(s: str, l: int, r: int) -> bool:\n#             while l < r:\n#                 if s[l] != s[r]:\n#                     return False\n#                 l += 1\n#                 r -= 1\n#             return True\n                \n#         ans, n = [], len(s)\n#         def backtrack(cur: List[str], start: int, ans: List[List[str]]):\n#             if start == n:\n#                 ans.append(cur[:])\n#             for end in range(start, n):\n#                 if isPalindrome(s, start, end):\n#                     # set\n#                     cur.append(s[start:end + 1])\n#                     backtrack(cur, end + 1, ans)\n#                     # clear\n#                     cur.pop()\n#         backtrack([], 0, ans)\n#         return ans\n    \n        \"\"\"\n        method 2: backtrack + memorization\n        \"\"\"\n        ans, n = [], len(s)\n        dp = [[False for _ in range(n)] for _ in range(n)]\n        def backtrack(cur: List[str], start: int, ans: List[List[str]]):\n            if start == n:\n                ans.append(cur[:])\n            for end in range(start, n):\n                if s[start] == s[end] and (end - start <= 2 or dp[start+1][end-1]):\n                    dp[start][end] = True\n                    backtrack(cur + [s[start:end + 1]], end + 1, ans)\n        backtrack([], 0, ans)\n        return ans","compare_result":"1111111111111111111111","title_slug":"palindrome-partitioning","has_notes":false,"flag_type":1}