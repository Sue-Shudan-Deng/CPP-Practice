{"id":405910887,"lang":"python3","lang_name":"Python3","time":"2 years, 11 months","timestamp":1602116276,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/405910887/","is_pending":"Not Pending","title":"Number of Islands","memory":"N/A","code":"# BFS\n# from collections import deque\n# class Solution:\n#     def numIslands(self, grid: List[List[str]]) -> int:\n#         if grid == []:\n#             return 0\n#         row = len(grid)\n#         column = len(grid[0])\n#         queue = deque()\n#         directions = [(0,1), (0,-1), (1,0), (-1,0)]\n#         count = 0\n        \n#         for r in range(row):\n#             for c in range(column):\n#                 if grid[r][c] == \"1\":\n#                     grid[r][c] = \"0\"\n#                     count += 1   \n#                     queue = deque([(r,c)])\n#                     while queue:\n#                         r_base, c_base = queue.popleft()\n#                         for d in range(len(directions)):\n#                             new_r = r_base + directions[d][0]\n#                             new_c = c_base + directions[d][1] \n#                             if not (new_r < 0 or new_r >= row or new_c < 0 or new_c >= column \\\n#                             or grid[new_r][new_c] == \"0\"):\n#                                 grid[new_r][new_c] = \"0\"\n#                                 queue.append((new_r, new_c))\n#         return count\n\n# DFS\n# class Solution:\n#     def numIslands(self, grid: List[List[str]]) -> int:\n#         if grid == []:\n#             return 0\n#         directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n#         row = len(grid)\n#         col = len(grid[0])\n#         res = 0\n\n#         def dfs(r: int, c: int):\n#             grid[r][c] = \"0\"\n#             for d in range(len(directions)):\n#                 new_r = r + directions[d][0]\n#                 new_c = c + directions[d][1]\n#                 if new_r < 0 or new_r >= row or new_c < 0 or new_c >= col or grid[new_r][new_c] == \"0\":\n#                     continue\n#                 dfs(new_r, new_c)\n                \n#         for r in range(row):\n#             for c in range(col):\n#                 if grid[r][c] == \"1\":\n#                     res += 1\n#                     dfs(r, c)\n        \n#         return res\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        \n        row, col = len(grid), len(grid[0])\n        parent = [0 for _ in range(row * col)]\n        size = [0 for _ in range(row * col)]\n        count = 0\n        for r in range(row):\n            for c in range(col):\n                if grid[r][c] == \"1\":\n                    parent[r * col + c] = r * col + c\n                    count += 1\n        \n        def find(x):\n            while x != parent[x]:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return parent[x]\n        \n        def union(x, y):\n            nonlocal count\n            px, py = find(x), find(y)\n            if px == py:\n                return\n            if size[px] > size[py]:\n                px, py = py, px\n            parent[px] = py\n            size[py] += size[px]\n            count -= 1\n        \n        for r in range(row):\n            for c in range(col):\n                if grid[r][c] == \"1\":\n                    grid[r][c] = \"0\"\n                    if r - 1 >= 0 and grid[r-1][c] == '0':\n                        union(r * col + c, (r - 1) * col + c)\n                    if c - 1 >= 0 and grid[r][c-1] == '0':\n                        union(r * col + c, r * col + (c - 1))\n                    if r + 1 < row and grid[r+1][c] == '0':\n                        union(r * col + c, (r + 1) * col + c)\n                    if c + 1 < col and grid[r][c+1] == '0':\n                        union(r * col + c, r * col + (c + 1))\n        \n        return count","compare_result":"10000000000000000000000000000000000000000000000","title_slug":"number-of-islands","has_notes":false,"flag_type":1}