{"id":396720452,"lang":"python3","lang_name":"Python3","time":"2 years, 11 months","timestamp":1600288256,"status":10,"status_display":"Accepted","runtime":"64 ms","url":"/submissions/detail/396720452/","is_pending":"Not Pending","title":"Split Array Largest Sum","memory":"14 MB","code":"class Solution:\n    \n    # method 1: DP: TLE\n    # def splitArray(self, nums: List[int], m: int) -> int:\n    #     n = len(nums)\n    #     dp = [[float(\"inf\") for j in range(m+1)] for i in range(n+1)]\n    #     summ = [0 for _ in range(n+1)]\n    #     for i in range(1, n+1):\n    #         summ[i] = summ[i-1] + nums[i-1]\n    #     dp[0][0] = 0\n    #     for i in range(1, n+1):\n    #         for j in range(1, m+1):\n    #             for k in range(0, i):\n    #                 dp[i][j] = min(dp[i][j], max(dp[k][j-1], (summ[i]-summ[k])))\n    #     return dp[-1][-1]\n    \n    # method 2: Binary search\n    def splitArray(self, nums: List[int], k: int) -> int:\n        l, r = max(nums), sum(nums)\n        ans = r\n        while l < r:\n            # calculate cnt\n            m = l + (r - l) // 2\n            summ = 0\n            cnt = 1\n            # how to calculate cnt\n            # 因为这里是最紧凑的计数方式，所以相当于算的是所有可能的subarray的总数的最大值\n            for n in nums:\n                if summ + n > m:\n                    cnt += 1\n                    summ = n\n                else:\n                    summ += n\n            if cnt <= k:\n                # 再往左走没有意义，因为cnt只会越来越小\n                ans = min(ans, m)\n                r = m\n            else:\n                l = m + 1\n        return ans","compare_result":"1111111111111111111111111111","title_slug":"split-array-largest-sum","has_notes":false,"flag_type":1}