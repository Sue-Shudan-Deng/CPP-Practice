{"id":409643478,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1602897075,"status":10,"status_display":"Accepted","runtime":"776 ms","url":"/submissions/detail/409643478/","is_pending":"Not Pending","title":"Find the Shortest Superstring","memory":"16.8 MB","code":"class Solution:\n    def __init__(self):\n        self.best_path = []\n    \n    def shortestSuperstring(self, A: List[str]) -> str:\n        \"\"\"\n        method 1: 当成一道常规的dfs + search问题来做\n        \"\"\"\n#         n = len(A)\n#         cost = [[0 for _ in range(n)] for _ in range(n)]\n#         # cost[i][j] represents number of letters needed of appending A[j] to A[i] \n#         for i in range(n):\n#             for j in range(n):\n#                 cost[i][j] = len(A[j])\n#                 for k in range(1, min(len(A[i]), len(A[j])) + 1):\n#                     if A[i][-k:] == A[j][:k]:\n#                         cost[i][j] = len(A[j]) - k\n                \n#         best_len = sum([len(n) for n in A])\n#         def dfs(depth, used, cur_len, cur_path):\n#             nonlocal best_len\n#             if cur_len > best_len:\n#                 return\n#             if depth == n:\n#                 best_len = cur_len\n#                 self.best_path = cur_path\n#                 return\n#             for i in range(n):\n#                 if used & (1 << i):\n#                     continue\n#                 dfs(depth + 1,\n#                     used | (1 << i),\n#                     cur_len + cost[cur_path[-1]][i]\n#                     if depth else len(A[i]),\n#                     cur_path + [i]\n#                    )\n                \n#         dfs(0, 0, 0, [])\n#         res = A[self.best_path[0]]\n#         for i in range(1, n):\n#             last = self.best_path[i-1]\n#             cur = self.best_path[i]\n#             res += A[cur][len(A[cur])-cost[last][cur]:]\n#         return res\n        \"\"\"\n        method 2: DP (TSP), https://www.youtube.com/watch?v=u_Wc4jwrp3Q\n        \"\"\"\n        n = len(A)\n        cost = [[0 for _ in range(n)] for _ in range(n)]\n        # cost[i][j] represents number of letters needed of appending A[j] to A[i] \n        for i in range(n):\n            for j in range(n):\n                cost[i][j] = len(A[j])\n                for k in range(1, min(len(A[i]), len(A[j])) + 1):\n                    if A[i][-k:] == A[j][:k]:\n                        cost[i][j] = len(A[j]) - k\n                        \n        dp = [[float(\"inf\") for _ in range(n)] for _ in range(1<<n)]\n        parent = [[-1 for _ in range(n)] for _ in range(1<<n)]\n        # child[s][i] = j: child of i is j\n        \n        for i in range(n):\n            dp[1<<i][i] = len(A[i])\n        for s in range(1, 1<<n):\n            for i in range(n):\n                if not s & (1<<i):\n                    continue\n                for j in range(n):\n                    if dp[s-(1<<i)][j] + cost[j][i] < dp[s][i]:\n                        dp[s][i] = dp[s-(1<<i)][j] + cost[j][i]\n                        parent[s][i] = j\n                        \n        cur = [k for (k,v) in enumerate(dp[s]) if v == min(dp[s])][0]\n        s, res = (1 << n) - 1, \"\"\n        while s:\n            pre = parent[s][cur]\n            if pre < 0:\n                res = A[cur] + res\n            else:\n                res = A[cur][-cost[pre][cur]:] + res\n            s -= (1 << cur)\n            cur = pre\n        return res\n        \n                    \n                    \n                    \n                    ","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-the-shortest-superstring","has_notes":false,"flag_type":1}