{"id":409553642,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1602875631,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/409553642/","is_pending":"Not Pending","title":"Find the Shortest Superstring","memory":"N/A","code":"class Solution:\n    def __init__(self):\n        self.best_path = []\n    \n    def shortestSuperstring(self, A: List[str]) -> str:\n        \"\"\"\n        method 1: 当成一道常规的dfs + search问题来做\n        \"\"\"\n        n = len(A)\n        cost = [[0 for _ in range(n)] for _ in range(n)]\n        # cost[i][j] represents number of letters needed of appending A[j] to A[i] \n        for i in range(n):\n            for j in range(n):\n                cost[i][j] = len(A[j])\n                for k in range(1, min(len(A[i]), len(A[j])) + 1):\n                    if A[i][-k:] == A[j][:k]:\n                        cost[i][j] = len(A[j]) - k\n                \n        best_len = sum([len(n) for n in A])\n        def dfs(depth, used, cur_len, cur_path):\n            nonlocal best_len\n            if cur_len > best_len:\n                return\n            if depth == n:\n                best_len = cur_len\n                self.best_path = cur_path\n                return\n            for i in range(n):\n                if used & (1 << i):\n                    continue\n                dfs(depth + 1,\n                    used | (1 << i),\n                    cur_len + cost[cur_path[-1]][i]\n                    if depth else len(A[i]),\n                    cur_path + [i]\n                   )\n                \n        dfs(0, 0, 0, [])\n        res = A[self.best_path[0]]\n        for i in range(1, n):\n            last = self.best_path[i-1]\n            cur = self.best_path[i]\n            res += A[cur][len(A[cur])-cost[last][cur]:]\n        return res","compare_result":"111111111111111111111111111111111111111111111111111111111111111111100000","title_slug":"find-the-shortest-superstring","has_notes":false,"flag_type":1}