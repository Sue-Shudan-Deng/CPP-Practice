{"id":419009811,"lang":"python3","lang_name":"Python3","time":"2 years, 9 months","timestamp":1605059371,"status":10,"status_display":"Accepted","runtime":"8480 ms","url":"/submissions/detail/419009811/","is_pending":"Not Pending","title":"Cut Off Trees for Golf Event","memory":"14.5 MB","code":"class Solution(object):\n    def cutOffTree(self, f):\n        row, col = len(f), len(f[0])\n        s = [(i,j) for i in range(row) for j in range(col) if f[i][j]]             \n        s.sort(key = lambda x: f[x[0]][x[1]])\n        s = [(0,0)] + s\n        \n        def bfs(source, target):\n            queue = collections.deque([(source, 0)])\n            visited = set()\n            while queue:\n                (r, c), steps = queue.popleft()\n                if (r, c) in visited:\n                    continue\n                visited.add((r, c))\n                if (r, c) == target:\n                    return steps\n                for nr, nc in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)):\n                    if 0 <= nr < row and 0 <= nc < col and f[nr][nc]:\n                        queue.append(((nr, nc), steps + 1))\n            return float('inf')\n        \n        cnt = 0\n        for u, v in zip(s, s[1:]): \n            res = bfs(u, v)\n            cnt += res\n            if cnt == float('inf'): \n                return -1\n        return cnt\n    \n","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"cut-off-trees-for-golf-event","has_notes":false,"flag_type":1}