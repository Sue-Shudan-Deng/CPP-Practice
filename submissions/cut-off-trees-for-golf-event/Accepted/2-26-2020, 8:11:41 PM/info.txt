{"id":307280517,"lang":"python3","lang_name":"Python3","time":"3Â years, 6Â months","timestamp":1582776701,"status":10,"status_display":"Accepted","runtime":"8808 ms","url":"/submissions/detail/307280517/","is_pending":"Not Pending","title":"Cut Off Trees for Golf Event","memory":"13.1 MB","code":"# class Solution:\n#     def cutOffTree(self, forest: List[List[int]]) -> int:\n#         row = len(forest)\n#         col = len(forest[0])\n#         node_list = []\n#         for r in range(row):\n#             for c in range(col):\n#                 if forest[r][c] != 0:\n#                     node_list.append((r, c, forest[r][c]))\n#         node_list = sorted(node_list, key=lambda node: node[2])\n#         nodes = list(map(lambda node: node[:-1], node_list))\n#         res = 0\n#         dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] \n        \n#         def bfs(r, c, nr, nc):\n#             queue = collections.deque([(r, c, 0)])\n#             visited = {}\n#             while queue:\n#                 i, j, step = queue.popleft()\n#                 visited[(i, j)] = True\n#                 if i == nr and j == nc:\n#                     return step \n#                 for d in dirs:\n#                     new_i, new_j = i + d[0], j + d[1]\n#                     if new_i >= 0 and new_i <= row - 1 and new_j >= 0 and new_j <= col - 1 and forest[new_i][new_j] != 0 and not visited.get((new_i, new_j), False):\n#                         queue.append((new_i, new_j, step + 1))\n#             return float(\"inf\")\n        \n#         for i in range(len(nodes)):\n#             if i == 0:\n#                 res += bfs(0, 0, nodes[i][0], nodes[i][1]) \n#             else:\n#                 res += bfs(nodes[i-1][0], nodes[i-1][1], nodes[i][0], nodes[i][1])\n#         return res if res != float(\"inf\") else -1\n\nclass Solution(object):\n    def cutOffTree(self, f):\n        s = [(i,j) for i in range(len(f)) for j in range(len(f[0])) if f[i][j]]                \n        s.sort(key = lambda x: f[x[0]][x[1]])\n        s = [(0,0)] + s\n        cumul = 0\n        for u,v in zip(s,s[1:]): \n            cumul += self.bfs(u,v,f)\n            if cumul == float('inf'): return -1\n        return cumul\n    \n    def bfs(self,source,target,grid):\n        q,vis = collections.deque([(source,0)]),set([source])\n        while(q):\n            u,steps  = q.popleft()\n            if u == target: return steps\n            for v in [(u[0]-1,u[1]), (u[0]+1,u[1]), (u[0],u[1]-1), (u[0],u[1]+1)]:\n                if 0 <= v[0] < len(grid) and 0 <= v[1] < len(grid[0]) and grid[v[0]][v[1]] != 0 and v not in vis:\n                    vis.add(v)\n                    q.append((v,steps + 1))\n        return float('inf')","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"cut-off-trees-for-golf-event","has_notes":false,"flag_type":1}