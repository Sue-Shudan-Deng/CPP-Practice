{"id":311870808,"lang":"python","lang_name":"Python","time":"3 years, 5 months","timestamp":1584040984,"status":10,"status_display":"Accepted","runtime":"8112 ms","url":"/submissions/detail/311870808/","is_pending":"Not Pending","title":"Cut Off Trees for Golf Event","memory":"12.5 MB","code":"class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        row, col = len(forest), len(forest[0])\n        f = [(r, c) for r in range(row) for c in range(col) if forest[r][c]]\n        f.sort(key = lambda (r, c): forest[r][c])\n        f = [(0, 0)] + f\n        cnt = 0\n        def neighbors(s):\n            for nr, nc in ((s[0] + 1, s[1]), (s[0], s[1] + 1), (s[0] - 1, s[1]), (s[0], s[1] - 1)):\n                if 0 <= nr < row and 0 <= nc < col and forest[nr][nc]:\n                    yield (nr, nc)\n        \n        def bfs(s, t):\n            seen, queue = set(s), collections.deque([(s, 0)])\n            while queue:\n                s, step = queue.popleft()\n                if s == t:\n                    return step\n                for ns in neighbors(s):\n                    if ns not in seen:\n                        seen.add(ns)\n                        queue.append((ns, step + 1))\n            return float(\"-inf\")\n        \n        for s, t in zip(f[:-1], f[1:]):\n            cnt += bfs(s, t)\n            if cnt == float(\"-inf\"):\n                return -1\n        return cnt","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"cut-off-trees-for-golf-event","has_notes":false,"flag_type":1}