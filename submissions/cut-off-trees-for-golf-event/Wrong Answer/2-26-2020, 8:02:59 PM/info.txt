{"id":307277993,"lang":"python3","lang_name":"Python3","time":"3Â years, 6Â months","timestamp":1582776179,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/307277993/","is_pending":"Not Pending","title":"Cut Off Trees for Golf Event","memory":"N/A","code":"class Solution:\n    def cutOffTree(self, forest: List[List[int]]) -> int:\n        row = len(forest)\n        col = len(forest[0])\n        node_list = []\n        for r in range(row):\n            for c in range(col):\n                if forest[r][c] != 0:\n                    node_list.append((r, c, forest[r][c]))\n        node_list = sorted(node_list, key=lambda node: node[2])\n        nodes = list(map(lambda node: node[:-1], node_list))\n        res = 0\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] \n        \n        def bfs(r, c, nr, nc):\n            queue = collections.deque([(r, c, 0)])\n            visited = {}\n            while queue:\n                i, j, step = queue.popleft()\n                visited[(i, j)] = True\n                if i == nr and j == nc:\n                    return step \n                for d in dirs:\n                    new_i, new_j = i + d[0], j + d[1]\n                    if new_i >= 0 and new_i <= row - 1 and new_j >= 0 and new_j <= col - 1 and forest[new_i][new_j] != 0 and not visited.get((new_i, new_j), False):\n                        queue.append((new_i, new_j, step + 1))\n            return float(\"inf\")\n        \n        for i in range(len(nodes) - 1):\n            res += bfs(nodes[i][0], nodes[i][1], nodes[i+1][0], nodes[i+1][1])\n        return res if res != float(\"inf\") else -1","compare_result":"11111111111010000000001000000000100000000000000000000","title_slug":"cut-off-trees-for-golf-event","has_notes":false,"flag_type":1}