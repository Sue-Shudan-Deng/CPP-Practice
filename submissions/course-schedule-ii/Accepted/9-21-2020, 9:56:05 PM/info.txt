{"id":399044855,"lang":"python3","lang_name":"Python3","time":"2 years, 11 months","timestamp":1600750565,"status":10,"status_display":"Accepted","runtime":"104 ms","url":"/submissions/detail/399044855/","is_pending":"Not Pending","title":"Course Schedule II","memory":"16.9 MB","code":"class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        \"\"\"\n        这道题需要认真理解\n        \"\"\"\n        graph = collections.defaultdict(list)\n        status = [\"unk\" for _ in range(numCourses)]\n        for p, q in prerequisites:\n            graph[q].append(p)\n            \n        def dfs(node, ans):\n            \"\"\"\n            whether or not can form a circle if we start from this node\n            \"\"\"\n            if status[node] == \"visited\":\n                return True  # True means OK\n            if status[node] == \"visiting\":\n                return False # False means CYCLE\n            # 所以某种意义上跟backtrack也没任何区别\n            # set\n            status[node] = \"visiting\"\n            # 这么写是错的！！！这样并不能保证一个节点的所有邻接节点恰好同时在之后被访问\n            # ans.append(node)\n            for nei in graph[node]:\n                if not dfs(nei, ans):\n                    return False\n            # clear\n            status[node] = \"visited\"\n            # 重点！！！！！这样写才可能保障每个节点的邻接节点恰好位于该节点前！！！\n            ans.append(node)\n            return True\n            \n        ans = []\n        for node in range(numCourses):\n            if not dfs(node, ans):\n                return []\n        return ans[::-1] # 重点！！逆序输出！！！","compare_result":"11111111111111111111111111111111111111111111","title_slug":"course-schedule-ii","has_notes":false,"flag_type":1}