{"id":400337442,"lang":"python3","lang_name":"Python3","time":"2 years, 11 months","timestamp":1600994128,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/400337442/","is_pending":"Not Pending","title":"Out of Boundary Paths","memory":"N/A","code":"class Solution:\n    def findPaths(self, m: int, n: int, N: int, i: int, j: int) -> int:\n        dp = [[[0 for _ in range(n)] for _ in range(m)] for _ in range(N+1)]\n        \n        \"\"\"\n        https://www.youtube.com/watch?v=92zh6XvqEgc\n        dp[s][r][c] 表示从边界外走多少步可以到[r, c]，等价于从r, c开始走有多少种办法可以出界\n        \"\"\"\n        mod = (10 ** 9 + 7)\n        dirs = [-1, 0, 1, 0, -1]\n        for s in range(1, N + 1):\n            for r in range(m):\n                for c in range(n):\n                    for d in range(4):\n                        new_r, new_c = r + dirs[d], c + dirs[d+1]\n                        # \"\"\"\n                        # 下面的写法太巧妙\n                        # 本质是 1 -> 2, 1 -> 3, 2, 1 -> 4, 3, 2, 1\n                        # 最后 4 + 3 + 2 + 1\n                        # \"\"\"\n                        # if new_r < 0 or new_r >= m or new_c < 0 or new_c >= n:\n                        #     dp[s][r][c] += 1\n                        # else:\n                        #     dp[s][r][c] = (dp[s][r][c] + dp[s-1][new_r][new_c]) % mod\n                            \n                        \"\"\"\n                        写法2：naive版\n                        \"\"\"\n                        if new_r < 0 or new_r >= m or new_c < 0 or new_c >= n:\n                            if s == 1:\n                                dp[s][r][c] += 1\n                        else:\n                            dp[s][r][c] = (dp[s][r][c] + dp[s-1][new_r][new_c]) % mod\n                            \n        return sum(dp[s][i][j] for s in range(1, N + 1))","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111101011010001110","title_slug":"out-of-boundary-paths","has_notes":false,"flag_type":1}