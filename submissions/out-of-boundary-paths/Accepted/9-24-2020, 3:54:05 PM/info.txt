{"id":400310637,"lang":"python3","lang_name":"Python3","time":"2 years, 11 months","timestamp":1600988045,"status":10,"status_display":"Accepted","runtime":"596 ms","url":"/submissions/detail/400310637/","is_pending":"Not Pending","title":"Out of Boundary Paths","memory":"18.1 MB","code":"class Solution:\n    def findPaths(self, m: int, n: int, N: int, i: int, j: int) -> int:\n        dp = [[[0 for _ in range(n+1)] for _ in range(m+1)] for _ in range(N+1)]\n        \n        \"\"\"\n        https://www.youtube.com/watch?v=92zh6XvqEgc\n        dp[s][r][c] 表示从边界外走多少步可以到[r, c]，等价于从r, c开始走有多少种办法可以出界\n        \"\"\"\n        dirs = [-1, 0, 1, 0, -1]\n        for s in range(1, N + 1):\n            for r in range(m):\n                for c in range(n):\n                    for d in range(4):\n                        new_r, new_c = r + dirs[d], c + dirs[d+1]\n                        if new_r < 0 or new_r >= m or new_c < 0 or new_c >= n:\n                            dp[s][r][c] += 1\n                        else:\n                            dp[s][r][c] = (dp[s][r][c] + dp[s-1][new_r][new_c]) % (10 ** 9 + 7)\n                            \n        return dp[N][i][j]","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"out-of-boundary-paths","has_notes":false,"flag_type":1}