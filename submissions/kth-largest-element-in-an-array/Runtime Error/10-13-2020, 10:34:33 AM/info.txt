{"id":408303744,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1602610473,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/408303744/","is_pending":"Not Pending","title":"Kth Largest Element in an Array","memory":"N/A","code":"class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Method 1: heap, O(nlogK)\n        \"\"\"\n        # return heapq.nlargest(k, nums)[-1]\n    \n        \"\"\"\n        Method 2: binary search \n        \"\"\"\n        # l, r = -2**31, 2**31-1\n        # while l < r:\n        #     m, c = l + (r - l) // 2, 0\n        #     for num in nums:\n        #         if num > m:\n        #             c += 1\n        #     if c <= k-1:\n        #         r = m\n        #     else:\n        #         l = m + 1\n        # return l\n        \"\"\"\n        Method 3: quick sort \n        \"\"\"\n        \n        \"\"\"\n        Method 4: quick select\n        \"\"\"\n        p = self.qselect(nums, 0, len(nums)-1, k) # 一定要注意，python是按引用传递的，不是按值传递，因此nums的值会修改\n        return nums[p]\n\n    def qselect(self, nums, lo, hi, k):\n        if lo < hi:\n            p = self.partition(nums, lo, hi)\n            if p == len(nums) - k:\n                return p\n            elif p > len(nums) - k:\n                return self.qselect(nums, lo, p - 1, k)\n            else:\n                return self.qselect(nums, p + 1, hi, k)\n    \n    def partition(self, lst, lo, hi):\n        \"\"\"\n        简单双向版本，pivot取lo\n        实践证明面试一定不要尝试三数取中法，edge case太麻烦\n        http://www.cs.armstrong.edu/liang/animation/web/QuickSortPartition.html\n        \"\"\"\n        pivot = lo\n        lo += 1\n        \n        # 3个while循环\n        while True:\n            while lo <= hi and lst[hi] >= lst[pivot]:\n                hi -= 1\n            while lo <= hi and lst[lo] <= lst[pivot]:\n                lo += 1\n            if lo <= hi:\n                lst[lo], lst[hi] = lst[hi], lst[lo]\n            else:\n                break\n        # 记住这里lo和hi恰好都错位：lo指向比pivot大的元素，hi指向比pivot小的元素\n        # 因此lo不用管，把hi换了就没问题了，这样hi右边恰好是比他大的元素，而左边一定是比它小的元素\n        lst[pivot], lst[hi] = lst[hi], lst[pivot]\n        return hi","compare_result":"11000000000000000000000000000000","title_slug":"kth-largest-element-in-an-array","has_notes":false,"flag_type":1}