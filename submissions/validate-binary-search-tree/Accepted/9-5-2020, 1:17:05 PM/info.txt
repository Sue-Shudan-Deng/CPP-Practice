{"id":391489319,"lang":"python3","lang_name":"Python3","time":"2 years, 12 months","timestamp":1599337025,"status":10,"status_display":"Accepted","runtime":"48 ms","url":"/submissions/detail/391489319/","is_pending":"Not Pending","title":"Validate Binary Search Tree","memory":"16.1 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        \"\"\"\n        最基本做法(Recursion)\n        1. 分别判断左右子树是否valid\n        2. 分别求出左右子树的最大和最小值，和根结点比较\n        \"\"\"\n        # Edge case\n        if not root or (not root.left and not root.right):\n            return True\n        \n        def minBST(root):\n            while root.left:\n                root = root.left\n            return root\n        \n        def maxBST(root):\n            while root.right:\n                root = root.right\n            return root\n        \n        left_max_valid = maxBST(root.left).val < root.val if root.left else True\n        right_min_valid = root.val < minBST(root.right).val if root.right else True\n        \n        return self.isValidBST(root.left) and self.isValidBST(root.right) and left_max_valid and right_min_valid\n    \nclass Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        \"\"\"\n        另一种思路(Recursion)\n        基本思想：确保在每一个递归部分的内部，必然满足左结点<根结点 并且 右结点>根结点 (严格)\n        \"\"\"\n        def isvalid(root, lower=float(\"-inf\"), upper=float(\"inf\")):\n            # Edge case\n            if not root:\n                return True\n            if root.val <= lower or root.val >= upper:\n                return False\n            return isvalid(root.left, lower, root.val) and isvalid(root.right, root.val, upper)\n        \n        return isvalid(root)\n            \nclass Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        \"\"\"\n        Iteration\n        基本思想：先序遍历，因为访问顺序是\"中\"左右，因此每次比较均可同时比较中间和左/右\n        \"\"\"\n        stack = [(root, float(\"-inf\"), float(\"inf\"))]\n        while stack:\n            curr, lower, upper = stack.pop()\n            if not curr:\n                continue\n            if curr.val <= lower or curr.val >= upper:\n                return False\n            stack.append((curr.right, curr.val, upper))\n            stack.append((curr.left, lower, curr.val))\n            \n        return True\n    \nclass Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        \"\"\"\n        Iteration\n        基本思想：中序遍历，必然是按照严格从小到大的顺序来访问的，这一点非常重要\n        \"\"\"\n        stack, inorder = [], float(\"-inf\")\n        while stack or root:\n            while root:\n                stack.append(root)\n                root = root.left\n            # 从左结点的最左边开始\n            root = stack.pop()\n            if root.val <= inorder:\n                return False\n            inorder = root.val\n            root = root.right\n        return True","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"validate-binary-search-tree","has_notes":false,"flag_type":1}