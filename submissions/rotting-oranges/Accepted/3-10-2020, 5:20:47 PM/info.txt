{"id":311342573,"lang":"python3","lang_name":"Python3","time":"3 years, 5 months","timestamp":1583886047,"status":10,"status_display":"Accepted","runtime":"48 ms","url":"/submissions/detail/311342573/","is_pending":"Not Pending","title":"Rotting Oranges","memory":"12.8 MB","code":"class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        row, col = len(grid), len(grid[0])\n        queue = collections.deque()\n        \n        for r in range(row):\n            for c in range(col):\n                if grid[r][c] == 2:\n                    queue.append((r, c, 0))\n                    \n        def neighbors(r, c):\n            for nr, nc in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)):\n                if 0 <= nr < row and 0 <= nc < col:\n                    yield nr, nc\n        lvl = 0\n        while queue:\n            r, c, lvl = queue.popleft()\n            for nr, nc in neighbors(r, c):\n                if grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    queue.append((nr, nc, lvl + 1))\n                    \n        if any(1 in row for row in grid):\n            return -1\n        return lvl","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rotting-oranges","has_notes":false,"flag_type":1}