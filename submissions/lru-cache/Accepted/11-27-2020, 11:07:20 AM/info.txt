{"id":424713864,"lang":"cpp","lang_name":"C++","time":"2 years, 9 months","timestamp":1606504040,"status":10,"status_display":"Accepted","runtime":"276 ms","url":"/submissions/detail/424713864/","is_pending":"Not Pending","title":"LRU Cache","memory":"43.2 MB","code":"class LRUCache {\npublic:\n    LRUCache(int capacity) : size(capacity) {}\n    \n    int get(int key) {\n        if (kv.count(key) == 0) return -1;\n        updateLRU(key);\n        return kv[key];\n    }\n    \n    void put(int key, int value) {\n        if (kv.size() == size && kv.count(key) == 0)\n            evict();\n        updateLRU(key);\n        kv[key] = value;\n    }\n    \nprivate:\n    int size;\n    list<int> lru;                              // MRU ... LRU\n    unordered_map<int, list<int>::iterator> mp; // key -> iterator\n    unordered_map<int, int> kv;                 // key -> value\n    \n    void updateLRU(int key) {\n        if (kv.count(key)) \n            lru.erase(mp[key]);\n        lru.push_front(key);\n        mp[key] = lru.begin();\n    }\n    void evict() {\n        mp.erase(lru.back());\n        kv.erase(lru.back());\n        lru.pop_back();\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"111111111111111111","title_slug":"lru-cache","has_notes":false,"flag_type":1}