{"id":391439858,"lang":"python3","lang_name":"Python3","time":"2 years, 12 months","timestamp":1599329037,"status":10,"status_display":"Accepted","runtime":"308 ms","url":"/submissions/detail/391439858/","is_pending":"Not Pending","title":"Sort an Array","memory":"19.7 MB","code":"# class Solution:\n#     def sortArray(self, nums: List[int]) -> List[int]:\n#         \"\"\"\n#         Counting sort, O(1)\n#         \"\"\"\n#         C, m, M, S = collections.Counter(nums), min(nums), max(nums), []\n#         for n in range(m, M+1):\n#             S.extend([n]*C[n])\n#         return S\n    \n# class Solution:\n#     def sortArray(self, nums: List[int]) -> List[int]:\n#         \"\"\"\n#         Bottom-up mergesort\n#         \"\"\"\n#         def merge(l1: List[int], l2: List[int]) -> List[int]:\n#             res = []\n#             left_cursor = 0\n#             right_cursor = 0\n#             while left_cursor < len(l1) and right_cursor < len(l2):\n#                 if l1[left_cursor] < l2[right_cursor]:\n#                     res.append(l1[left_cursor])\n#                     left_cursor += 1\n#                 else:\n#                     res.append(l2[right_cursor])\n#                     right_cursor += 1\n#             res.extend(l1[left_cursor:])\n#             res.extend(l2[right_cursor:])\n#             return res\n            \n#         size = 1\n#         while size < len(nums):\n#             size += size\n#             for pos in range(0, len(nums), size):  # 这一步的想法是关键\n#                 start = pos\n#                 mid = pos + size // 2\n#                 end = pos + size\n#                 nums[start:end] = merge(nums[start:mid], nums[mid:end])\n#                 print(start, mid, end, nums)\n#         return nums\n              \nclass Solution:        \n    def sortArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        quick sort\n        \"\"\"\n        self.qsort(nums, 0, len(nums)-1) # 一定要注意，python是按引用传递的，不是按值传递，因此nums的值会修改\n        return nums\n\n    def qsort(self, lst, lo, hi):\n        if lo < hi:\n            p = self.partition(lst, lo, hi)\n            self.qsort(lst, lo, p - 1)\n            self.qsort(lst, p + 1, hi)\n    \n    def partition(self, lst, lo, hi):\n        \"\"\"\n        简单双向版本，pivot取lo\n        实践证明面试一定不要尝试三数取中法，edge case太麻烦\n        http://www.cs.armstrong.edu/liang/animation/web/QuickSortPartition.html\n        \"\"\"\n        pivot = lo\n        lo += 1\n        \n        # 3个while循环\n        while True:\n            while lo <= hi and lst[hi] >= lst[pivot]:\n                hi -= 1\n            while lo <= hi and lst[lo] <= lst[pivot]:\n                lo += 1\n            if lo <= hi:\n                lst[lo], lst[hi] = lst[hi], lst[lo]\n            else:\n                break            \n        # 记住这里lo和hi恰好都错位：lo指向比pivot大的元素，hi指向比pivot小的元素\n        # 因此lo不用管，把hi换了就没问题了，这样hi右边恰好是比他大的元素，而左边一定是比它小的元素\n        lst[pivot], lst[hi] = lst[hi], lst[pivot]\n        return hi","compare_result":"11111111111","title_slug":"sort-an-array","has_notes":false,"flag_type":1}