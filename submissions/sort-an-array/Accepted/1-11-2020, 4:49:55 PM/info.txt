{"id":293353268,"lang":"python3","lang_name":"Python3","time":"3 years, 7 months","timestamp":1578790195,"status":10,"status_display":"Accepted","runtime":"276 ms","url":"/submissions/detail/293353268/","is_pending":"Not Pending","title":"Sort an Array","memory":"19.2 MB","code":"class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Counting sort，赖皮\n        \"\"\"\n        C, m, M, S = collections.Counter(nums), min(nums), max(nums), []\n        for n in range(m, M+1):\n            S.extend([n]*C[n])\n        return S\n    \nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Bottom-up mergesort\n        \"\"\"\n        def merge(l1: List[int], l2: List[int]) -> List[int]:\n            res = []\n            left_cursor = 0\n            right_cursor = 0\n            while left_cursor < len(l1) and right_cursor < len(l2):\n                if l1[left_cursor] < l2[right_cursor]:\n                    res.append(l1[left_cursor])\n                    left_cursor += 1\n                else:\n                    res.append(l2[right_cursor])\n                    right_cursor += 1\n            res.extend(l1[left_cursor:])\n            res.extend(l2[right_cursor:])\n            return res\n            \n        size = 1\n        while size < len(nums):\n            size += size\n            for pos in range(0, len(nums), size):  # 这一步的想法是关键\n                start = pos\n                mid = pos + size // 2\n                end = pos + size\n                nums[start:end] = merge(nums[start:mid], nums[mid:end])\n        return nums\n              \nclass Solution:        \n    def sortArray(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        quick sort\n        \"\"\"\n        n = len(nums)\n        self.qsort(nums, 0, n - 1) # 一定要注意，python是按引用传递的，不是按值传递，因此nums的值会修改\n        return nums\n\n    def qsort(self, lst, lo, hi):\n        \"\"\"\n        Helper\n        :param lst: the list to sort\n        :param lo:  the index of the first element in the list\n        :param hi:  the index of the last element in the list\n        :return: the sorted list\n        \"\"\"\n        if lo < hi:\n            p = self.partition(lst, lo, hi)\n            # print(lst, hi, p)\n            self.qsort(lst, lo, p - 1)\n            # print(lst, hi)\n            self.qsort(lst, p + 1, hi)\n\n    # def partition(self, lst, lo, hi):\n    #     \"\"\"\n    #     Picks the last element hi as a pivot\n    #     and returns the index of pivot value in the sorted array\n    #     注：这里的partition算法是单向版本\n    #     \"\"\"\n    #     pivot = lst[hi]\n    #     i = lo\n    #     for j in range(lo, hi):\n    #         if lst[j] < pivot:\n    #             lst[i], lst[j] = lst[j], lst[i]\n    #             i += 1\n    #     lst[i], lst[hi] = lst[hi], lst[i]\n    #     return i\n    \n    def partition(self, array, start, end):\n        pivot = array[start]\n        low = start + 1\n        high = end\n\n        while True:\n            # If the current value we're looking at is larger than the pivot\n            # it's in the right place (right side of pivot) and we can move left,\n            # to the next element.\n            # We also need to make sure we haven't surpassed the low pointer, since that\n            # indicates we have already moved all the elements to their correct side of the pivot\n            while low <= high and array[high] >= pivot:\n                high = high - 1\n\n            # Opposite process of the one above\n            while low <= high and array[low] <= pivot:\n                low = low + 1\n\n            # We either found a value for both high and low that is out of order\n            # or low is higher than high, in which case we exit the loop\n            if low <= high:\n                array[low], array[high] = array[high], array[low]\n                # The loop continues\n            else:\n                # We exit out of the loop\n                break\n\n        array[start], array[high] = array[high], array[start]\n\n        return high","compare_result":"1111111111","title_slug":"sort-an-array","has_notes":false,"flag_type":1}