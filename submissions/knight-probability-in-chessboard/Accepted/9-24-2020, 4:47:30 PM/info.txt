{"id":400324085,"lang":"python3","lang_name":"Python3","time":"2 years, 11 months","timestamp":1600991250,"status":10,"status_display":"Accepted","runtime":"280 ms","url":"/submissions/detail/400324085/","is_pending":"Not Pending","title":"Knight Probability in Chessboard","memory":"14.9 MB","code":"class Solution:\n    def knightProbability(self, N: int, K: int, i: int, j: int) -> float:\n        dp = [[[0 for _ in range(N)] for _ in range(N)] for _ in range(K + 1)]\n        \"\"\"\n        dp[s][r][c] 记录从r, c开始，走s步出界\n        \"\"\"\n        dirs = [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]\n        dp[0][i][j] = 1\n        for s in range(1, K + 1):\n            for r in range(N):\n                for c in range(N):\n                    for dr, dc in dirs:\n                        new_r, new_c = r + dr, c + dc\n                        if 0 <= new_r < N and 0 <= new_c < N:\n                            dp[s][r][c] += dp[s-1][new_r][new_c]\n                \n        total = 0\n        for i in range(N):\n            for j in range(N):\n                total += dp[K][i][j]\n        return total * (1/8) ** K","compare_result":"111111111111111111111","title_slug":"knight-probability-in-chessboard","has_notes":false,"flag_type":1}