{"id":409238734,"lang":"python3","lang_name":"Python3","time":"2 years, 10 months","timestamp":1602807027,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/409238734/","is_pending":"Not Pending","title":"Cherry Pickup","memory":"N/A","code":"class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        https://www.youtube.com/watch?v=vvPSWORCKow&t=641s\n        难点1: 往返走两次相当于两个人以一个方向走一次\n        难点2: 同时走可以节省一个复杂度\n        \"\"\"\n        n = len(grid)\n        dp = [[[float(\"-inf\") for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]\n        for i in range(n + 1):\n            for j in range(n + 1):\n                dp[0][i][j] = 0\n                dp[i][0][j] = 0\n                dp[i][j][0] = 0\n        # dp[x1][x2][y1]: (x1, y1), (x2, y2) 时走到(N-1, N-1) 最多的cherry是多少\n        # y2 = x1 + y1 - x2\n        for x1 in range(1, n + 1):\n            for y1 in range(1, n + 1):\n                if grid[x1-1][y1-1] == -1:\n                    continue\n                for x2 in range(max(1, x1 + y1 - n), min(x1 + y1, n + 1)):\n                    y2 = x1 + y1 - x2\n                    if grid[x2-1][y2-1] == -1:\n                        continue\n                    dp[x1][y1][x2] = grid[x1-1][y1-1] + grid[x2-1][y2-1] - (x1 == x2 and y1 == y2) + max(dp[x1-1][y1][x2-1], dp[x1-1][y1][x2], dp[x1][y1-1][x2-1], dp[x1][y1-1][x2])\n\n        return dp[-1][-1][-1] if dp[-1][-1][-1] != float(\"-inf\") else 0","compare_result":"11011101111111111011110001011110111001111111111111110111","title_slug":"cherry-pickup","has_notes":false,"flag_type":1}